%==============================================================================
\section{Άσκηση 1: Αριθμητική/Λογική Μονάδα (ALU)}
%==============================================================================

\subsection{Περιγραφή}

Η ALU είναι ένα συνδυαστικό κύκλωμα 32-bit που υλοποιεί δώδεκα διαφορετικές λειτουργίες, κατηγοριοποιημένες σε τέσσερεις ομάδες: λογικές πράξεις, αριθμητικές πράξεις και πράξεις λογικής κι αριθμιτικής ολίσθησης.

\begin{table}[H]
\centering
\caption{Πίνακας λειτουργιών ALU}
\label{alu_ops}
\begin{tabular}{|c|l|}
\hline
\textbf{alu\_op} & \textbf{Κατηγορία - Λειτουργία} \\
\hline
1000 & Λογική - AND \\
1001 & Λογική - OR \\
1010 & Λογική - NOR \\
1011 & Λογική - NAND \\
1100 & Λογική - XOR \\
\hdashline
0100 & Προσημασμένη - Πρόσθεση \\
0101 & Προσημασμένη - Αφαίρεση \\
0110 & Προσημασμένος - Πολλαπλασιασμός \\
\hdashline
0000 & Λογική ολίσθηση - Δεξιά \\
0001 & Λογική ολίσθηση - Αριστερά \\
\hdashline
0010 & Αριθμητική ολίσθηση - Δεξιά \\
0011 & Αριθμητική ολίσθηση - Αριστερά \\
\hline
\end{tabular}
\end{table}

\subsection{Αρχιτεκτονική}
Η ALU σχεδιάστηκε ως συνδυαστικό κύκλωμα με τις ακόλουθες θύρες εισόδου/εξόδου:

\begin{table}[H]
\centering
\caption{Θύρες του module ALU}
\begin{tabular}{|l|c|c|p{7cm}|}
\hline
\textbf{Θύρα} & \textbf{Κατεύθυνση} & \textbf{Πλάτος} & \textbf{Περιγραφή} \\
\hline
\texttt{op1} & Είσοδος & 32 & Τελεστής 1 σε συμπλήρωμα ως προς 2 \\
\texttt{op2} & Είσοδος & 32 & Τελεστής 2 σε συμπλήρωμα ως προς 2 \\
\texttt{alu\_op} & Είσοδος & 4 & Κωδικός επιλογής λειτουργίας \\
\hdashline
\texttt{result} & Έξοδος & 32 & Αποτέλεσμα της λειτουργίας \\
\texttt{zero} & Έξοδος & 1 & Σημαία μηδενικού αποτελέσματος \\
\texttt{ovf} & Έξοδος & 1 & Σημαία υπερχείλισης \\
\hline
\end{tabular}
\end{table}

\subsubsection{Λειτουργίες ALU}

\paragraph{Λογικές Πράξεις:}
Οι λογικές πράξεις (AND, OR, NOR, NAND, XOR) εκτελούνται bit-wise μεταξύ των δύο τελεστέων. Δεν παράγουν υπερχείλιση, συνεπώς το σήμα \texttt{ovf} παραμένει πάντα 0.

\paragraph{Αριθμητικές Πράξεις:}
Οι αριθμητικές πράξεις (πρόσθεση, αφαίρεση, πολλαπλασιασμός) εκτελούνται σε αριθμούς συμπληρώματος ως προς 2 και περιλαμβάνουν μηχανισμό ανίχνευσης υπερχείλισης.

\paragraph{Πράξεις Ολίσθησης:}
Οι πράξεις ολίσθησης μετακινούν τα bits του \texttt{op1} κατά τον αριθμό θέσεων που καθορίζεται από το \texttt{op2}. Πάρθηκε η απόφαση να χρησιμοποιούνται μόνο \textbf{τα 5 λιγότερο σημαντικά bits} του \texttt{op2} (bits 4:0), επιτρέποντας ολισθήσεις από 0 έως 31 θέσεις, καθώς για έναν καταχωρητή 32-bit, ολίσθηση πέρα από 31 θέσεις δεν έχει πρακτική σημασία. Ανοφορικά με κενά bits που δημιουργούνται, αυτά κατά περίπτωση:

\begin{itemize}
    \item \textbf{Λογική ολίσθηση (SRL \& SLL):} Τα κενά bits συμπληρώνονται με 0.
    \item \textbf{Αριθμητική ολίσθηση δεξιά (SRA \& SLA):} Τα κενά bits συμπληρώνονται έτσι ώστε να διατηρείται το πρόσημο του \texttt{op1} (sign extension).
\end{itemize}

\subsection{Ανίχνευση Υπερχείλισης}
Η υπερχείλιση συμβαίνει όταν το αποτέλεσμα μιας αριθμητικής πράξης δεν μπορεί να αναπαρασταθεί σωστά σε 32 bits συμπληρώματος ως προς 2. Στην αναπαράσταση συμπληρώματος ως προς 2, το bit 31 (MSB) αποτελεί το \textbf{bit προσήμου}: 0 για θετικούς αριθμούς, 1 για αρνητικούς.

\subsubsection{Πρόσθεση}

Η υπερχείλιση στην πρόσθεση ανιχνεύεται με την παρακάτω λογική, καθώς υπερχείλιση συμβαίνει μόνο όταν προσθέτουμε δύο αριθμούς με το \textbf{ίδιο πρόσημο} και το αποτέλεσμα έχει \textbf{διαφορετικό πρόσημο}:
\begin{lstlisting}[language=Verilog]
ovf = (op1[31] == op2[31]) && (result[31] != op1[31]);
\end{lstlisting}

\justify
\textbf{Περιπτώσεις:}
\begin{itemize}
    \item Θετικός + Θετικός = Αρνητικός $\rightarrow$ Υπερχείλιση
    \item Αρνητικός + Αρνητικός = Θετικός $\rightarrow$ Υπερχείλιση
    \item Θετικός + Αρνητικός = Οποιοδήποτε $\rightarrow$ Όχι υπερχείλιση (το άθροισμα είναι πάντα εντός ορίων)
\end{itemize}
\justify
\textbf{Παράδειγμα:} \\
\texttt{0x7FFFFFFF} (max θετικός: $2^{31}-1$) + \texttt{0x00000001} = \texttt{0x80000000} (max αρνητικός: $-2^{31}$) \\
$\Rightarrow$ \texttt{op1[31]=0}, \texttt{op2[31]=0}, \texttt{result[31]=1} $\Rightarrow$ \texttt{ovf=1}

\subsubsection{Αφαίρεση}

Η υπερχείλιση στην αφαίρεση ανιχνεύεται με την παρακάτω λογική, καθώς υπερχείλιση συμβαίνει όταν αφαιρούμε αριθμούς με \textbf{διαφορετικό πρόσημο} και το αποτέλεσμα έχει το \textbf{ίδιο πρόσημο με τον αφαιρετέο} (op2): 
\begin{lstlisting}[language=Verilog]
ovf = (op1[31] != op2[31]) && (result[31] == op2[31]);
\end{lstlisting}
\justify
\textbf{Περιπτώσεις:}
\begin{itemize}
    \item Θετικός - Αρνητικός = Αρνητικός $\rightarrow$ Υπερχείλιση
    \item Αρνητικός - Θετικός = Θετικός $\rightarrow$ Υπερχείλιση
    \item Θετικός - Θετικός = Οποιοδήποτε $\rightarrow$ Όχι υπερχείλιση
\end{itemize}
\justify
\textbf{Παράδειγμα:} \\
\texttt{0x7FFFFFFF} (max θετικός) - \texttt{0x80000000} (max αρνητικός) = \texttt{0xFFFFFFFF} (αρνητικός) \\
$\Rightarrow$ \texttt{op1[31]=0}, \texttt{op2[31]=1}, \texttt{result[31]=1} $\Rightarrow$ \texttt{ovf=1}

\subsubsection{Πολλαπλασιασμός}
Ο πολλαπλασιασμός δύο αριθμών 32-bit παράγει αποτέλεσμα 64-bit. Η υπερχείλιση ανιχνεύεται ελέγχοντας αν τα υψηλότερα 33 bits (bits 63:31) είναι έγκυρη επέκταση προσήμου του bit 31:

\begin{lstlisting}[language=Verilog]
ovf = (mult_result[63:31] != {33{mult_result[31]}}) &&
      (mult_result[63:31] != 33'b0);
\end{lstlisting}
\justify
\textbf{Περιπτώσεις:} Για να χωρέσει το αποτέλεσμα σε 32 bits, τα bits 63:31 πρέπει να είναι:
\begin{itemize}
    \item Όλα 1 (αν το bit 31 είναι 1, για αρνητικούς αριθμούς), ή
    \item Όλα 0 (για θετικούς αριθμούς που χωρούν σε 32 bits)
\end{itemize}

Αν καμία από τις δύο συνθήκες δεν ισχύει, το αποτέλεσμα είναι πολύ μεγάλο ή πολύ μικρό για να αναπαρασταθεί σε 32 bits.
\newpage