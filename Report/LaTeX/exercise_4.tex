%=======================================================================
\section{Άσκηση 4: Νευρωνικό Δίκτυο}
%=======================================================================

\subsection{Περιγραφή}

Σε αυτή την άσκηση υλοποιήθηκε ένας AI Accelerator που εκτελεί ένα απλό νευρωνικό δίκτυο 3 νευρώνων. Το σύστημα ενσωματώνει modules προηγούμενων ασκήσεων, αλλά και νέα modules:
\begin{itemize}
    \item \textbf{ALU} (Άσκηση 1): Για τις πράξεις ολίσθησης (preprocessing/postprocessing).
    \item \textbf{Register File} (Άσκηση 3): Για την αποθήκευση βαρών και πολώσεων.
    \item \textbf{MAC Unit}: Για την εκτέλεση των Multiply / Accumulate σου νευρώνες.
    \item \textbf{ROM}: Για την αρχική φόρτωση των παραμέτρων στο Register File.
\end{itemize}

\subsection{Αρχιτεκτονική}
Το module \texttt{nn} υλοποιήθηκε ως ακολουθιακό κύκλωμα ελεγχόμενο από FSM, με τις ακόλουθες θύρες:

\begin{table}[H]
\centering
\caption{Θύρες του module nn}
\begin{tabular}{|l|c|c|p{6cm}|}
\hline
\textbf{Θύρα} & \textbf{Κατεύθυνση} & \textbf{Πλάτος} & \textbf{Περιγραφή} \\
\hline
\texttt{clk} & Είσοδος & 1 & Σήμα ρολογιού \\
\texttt{resetn} & Είσοδος & 1 & Σήμα επαναφοράς (active low) \\
\texttt{enable} & Είσοδος & 1 & Σήμα ενεργοποίησης \\
\texttt{input\_1} & Είσοδος & 32 & Πρώτη είσοδος \\
\texttt{input\_2} & Είσοδος & 32 & Δεύτερη είσοδος \\
\hdashline
\texttt{total\_ovf} & Έξοδος & 1 & Ένδειξη υπερχείλισης \\
\texttt{total\_zero} & Έξοδος & 1 & Ένδειξη μηδενικού αποτελέσματος \\
\texttt{ovf\_fsm\_stage} & Έξοδος & 3 & Στάδιο υπερχείλισης \\
\texttt{zero\_fsm\_stage} & Έξοδος & 3 & Στάδιο μηδενισμού  \\
\texttt{final\_output} & Έξοδος & 32 & Τελικό αποτέλεσμα \\
\hline
\end{tabular}
\end{table}

\subsubsection{Αρχιτεκτονική Νευρωνικού}

Το νευρωνικό δίκτυο αποτελείται από 3 νευρώνες και υλοποιεί την ακόλουθη λογική:

\begin{align}
\text{inter}_1 &= \text{input}_1 >>> \text{shift\_bias}_1 \\
\text{inter}_2 &= \text{input}_2 >>> \text{shift\_bias}_2 \\
\text{inter}_3 &= \text{inter}_1 \times \text{weight}_1 + \text{bias}_1 \\
\text{inter}_4 &= \text{inter}_2 \times \text{weight}_2 + \text{bias}_2 \\
\text{inter}_5 &= \text{inter}_3 \times \text{weight}_3 + \text{inter}_4 \times \text{weight}_4 + \text{bias}_3 \\
\text{output} &= \text{inter}_5 <<< \text{shift\_bias}_3
\end{align}

\subsubsection{MAC Unit}

Η μονάδα MAC (Multiply and Accumulate) υλοποιεί:
\[
\text{result} = (\text{op1} \times \text{op2}) + \text{op3}
\]
\justify
Αποτελείται από δύο σειριακά συνδεδεμένες ALU:
\begin{enumerate}
    \item Πρώτη ALU: Πολλαπλασιασμός (op1 × op2)
    \item Δεύτερη ALU: Πρόσθεση (result1 + op3)
\end{enumerate}

\subsection{Finite State Machine (FSM)}

\subsubsection{Τύπος FSM: Registered Mealy}

Επιλέχθηκε \textbf{Registered Mealy FSM} (Σύγχρονη Mealy) για τους εξής λόγους:
\begin{itemize}
    \item \textbf{Εξάρτηση εξόδων από εισόδους:} Οι έξοδοι (\texttt{final\_output}, \texttt{total\_ovf}) εξαρτώνται τόσο από την τρέχουσα κατάσταση όσο και από τα σήματα εισόδου (\texttt{alu1\_ovf}, \texttt{alu2\_ovf}, \texttt{mac1\_ovf\_*}, \texttt{mac2\_ovf\_*}).
    \item \textbf{Registered outputs:} Επειδή η λογική εξόδων βρίσκεται μέσα σε \texttt{always @(posedge clk)}, οι έξοδοι είναι \textbf{σύγχρονες}, εξαλείφοντας glitches και εξασφαλίζοντας σταθερές τιμές για ολόκληρο τον κύκλο ρολογιού
    \item \textbf{Καθυστέρηση ενός κύκλου:} Η αλλαγή εξόδων εμφανίζεται στην \textit{επόμενη} ακμή ρολογιού μετά τον εντοπισμό συνθήκης (π.χ. overflow), παρέχοντας πιο εύκολο timing closure
\end{itemize}

\subsubsection{Διάγραμμα Καταστάσεων FSM}
Το ακόλουθο διάγραμμα απεικονίζει το FSM 7 καταστάσεων (Figure \ref{fig:fsm_diagram}). Πρακτικά το  Output Layer (S5) υλοποιήθηκε σε δύο καταστάσεις (έτσι ώστε να εκτελείται σε 2 κυκλους του ρολογιού) για την αποφυγή combinatorial loops (βλ. παρ. 5.3.4).

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    scale=0.7, 
    transform shape, 
    ->, >=Stealth, auto, semithick,
    node distance = 2.8cm and 3.2cm,
    state/.style = {
        circle, 
        draw, 
        minimum width = 3.5cm,
        align=center, 
        font=\bfseries\footnotesize,
        fill=white
    },
    initial text = {Reset}
]

    % --- Nodes (States) ---
    \node[state, fill=blue!10, initial below] (s0) {S0 \\ DEACTIVATED};
    \node[state, fill=blue!10] (s1) [right=of s0] {S1 \\ LOADING \\ (Weights/Biases)};
    \node[state, fill=green!10] (s2) [below=of s1] {S2 \\ IDLE};
    \node[state] (s3) [right=of s2] {S3 \\ PRE-PROC \\ (Shift Inputs)};
    \node[state] (s4) [right=of s3] {S4 \\ INPUT LAYER \\ (Neurons 1\&2)};
    \node[state] (s5) [below=of s4] {S5 \\ OUTPUT \\ LAYER \\ (Neuron 3)};
    \node[state] (s6) [left=of s5]  {S6 \\ POST-PROC \\ (Final Shift)};

    % --- Transitions ---
    \path (s0) edge node {enable=1} (s1);
    \path (s1) edge [loop right] node {cnt $<$ limit} (s1);
    \path (s1) edge node {done} (s2);
    \path (s2) edge [loop left] node {enable=0} (s2);
    \path (s2) edge node {enable=1} (s3);
    \path (s3) edge node [below] {!ovf} (s4);
    \path (s4) edge node [right] {!ovf} (s5);
    \path (s5) edge node [above] {!ovf} (s6);
    \path (s6) edge [bend left=45] node [left, midway] {Done} (s2);

    % Overflow Handling (Red Dashed Lines)
    \draw [red, dashed, thick] (s3) edge [bend right=45] node [above, sloped] {OVF} (s2);
    \draw [red, dashed, thick] (s4) edge [bend right=55] node [above, near start] {OVF} (s2);
    \draw [red, dashed, thick] (s5) edge [bend left=10] node [above, near start] {OVF} (s2);
    \draw [red, dashed, thick] (s6) edge [bend left=15] node [left, near start] {OVF} (s2);

    % --- Legend/Notes ---
    \node [draw, rectangle, align=left, font=\scriptsize,
            above left=-1cm and 9.5cm of s6.east
          ] {
        \large
        \textcolor{blue}{Blue Nodes}: Initialization\\
        \\[0.1ex]\large
        \textcolor{green!50!black}{Green Node}: Ready State\\
        \\[0.1ex]\large
        \textcolor{black}{White Nodes}: Normal Processing\\
        \\[0.1ex]\large
        \textcolor{red}{Red Dashed}: Overflow Exception\\
    };

\end{tikzpicture}
\caption{Διάγραμμα καταστάσεων FSM του Neural Network Accelerator.}
\label{fig:fsm_diagram}
\end{figure}

\subsubsection{Περιγραφή Καταστάσεων}

\begin{table}[H]
\centering
\caption{Καταστάσεις FSM με διαδοχική κωδικοποίηση (8 states)}
\begin{tabular}{|c|c|c|p{6.5cm}|}
\hline
\textbf{Κατάσταση} & \textbf{ID} & \textbf{Κωδικός} & \textbf{Περιγραφή} \\
\hline
S\_DEACTIVATED & S0 & 000 & Αρχική κατάσταση μετά από reset \\&&&\\
S\_LOADING & S1 & 001 & Φόρτωση βαρών/πολώσεων από τη ROM στο RegFile \\
S\_IDLE & S2 & 010 & Αναμονή για νέες εισόδους (Ready state) \\
S\_PREPROCESS & S3 & 011 & Αριθμητική ολίσθηση δεξιά στις εισόδους \\
S\_INPUT\_LAYER & S4 & 100 & Εκτέλεση νευρώνων 1 και 2 (παράλληλα) \\
S\_OUTPUT\_LAYER1 & S5a & 101 & Νευρώνας 3 - Πρώτο MAC: inter\_3 × w3 + b3 \\
S\_OUTPUT\_LAYER2 & S5b & 110 & Νευρώνας 3 - Δεύτερο MAC: inter\_4 × w4 + mac1\_temp \\
S\_POSTPROCESS & S6 & 111 & Αριθμητική ολίσθηση αριστερά στην έξοδο \\
\hline
\end{tabular}
\end{table}

\subsubsection{Σχεδιαστική Απόφαση Υλοποίησης: Διαχωρισμός Output Layer}

Παρόλο που η εκφώνηση ζητά 7 στάδια, η πρακτική υλοποίηση στο \texttt{nn.v} χρησιμοποιεί \textbf{8 καταστάσεις}. Η αιτία εξηγείται παρακάτω.

Το output layer του νευρωνικού δικτύου απαιτεί τον υπολογισμό:
\begin{align}
\text{inter}_5 &= \text{inter}_3 \times \text{weight}_3 + \text{inter}_4 \times \text{weight}_4 + \text{bias}_3
\end{align}

Σύμφωνα με την εκφώνηση αυτή η απαίτηση υλοποιείται ως εξής:
\begin{align}
\text{mac3} &= \text{inter}_3 \times \text{weight}_3 + \text{bias}_3 \quad \text{(MAC1 στο S5a)} \\
\text{inter}_5 &= \text{inter}_4 \times \text{weight}_4 + \text{mac3} \quad \text{(MAC2 στο S5b)}
\end{align}
\justify
\textbf{Ωστόσο:} Αν προσπαθήσουμε να εκτελέσουμε και τα δύο MAC σε ένα κύκλο θα δημιουργηθεί \textbf{combinatorial loop} διότι:
\begin{itemize}
    \item Το MAC1 είναι συνδυαστικό κύκλωμα (χωρίς ρολόι)
    \item Η έξοδος του MAC1 (\texttt{mac1\_result}) τροφοδοτείται στην είσοδο του MAC2
    \item Το MAC2 είναι επίσης συνδυαστικό
    \item Δεν υπάρχει καταχωρητής που να ``σπάει'' τον βρόχο
\end{itemize}
\begin{lstlisting}[caption=Προβληματικός κώδικας (combinatorial loop)]
// Zero-delay loop - Exit 137 (timeout)
mac2_op3 = mac1_result;  // Direct connection
\end{lstlisting}
\justify
\textbf{Λύση: Pipelining με Register}

Διαχωρίζουμε το output layer σε \textbf{δύο καταστάσεις} χρησιμοποιώντας και τις δύο MAC μονάδες σειριακά (όπως αναφέρει και η εκφώνηση):

\begin{enumerate}
    \item \textbf{S\_OUTPUT\_LAYER1 (S5a):} 
    \begin{itemize}
        \item MAC1 υπολογίζει: \texttt{mac1\_result = inter\_3 × weight\_3 + bias\_3}
        \item Το αποτέλεσμα αποθηκεύεται σε register (\texttt{mac1\_temp}) στο τέλος του κύκλου
    \end{itemize}
    
    \item \textbf{S\_OUTPUT\_LAYER2 (S5b)}: 
    \begin{itemize}
        \item MAC2 υπολογίζει: \texttt{mac2\_result = inter\_4 × weight\_4 + mac1\_temp}
        \item Χρησιμοποιεί το \textbf{registered} αποτέλεσμα (\texttt{mac1\_temp}) από τον προηγούμενο κύκλο
        \item Αποθηκεύει το τελικό αποτέλεσμα στο \texttt{inter\_5}
    \end{itemize}
\end{enumerate}

\subsection{Χειρισμός Υπερχείλισης: Ασυμφωνία στο \texttt{nn\_model.v}}
Παρατηρήθηκε ότι αν και η εκφώνηση αναφέρει ότι σε περίπτωση overflow η έξοδος πρέπει να είναι ο \textbf{``μέγιστος δυνατός θετικός αριθμός''} (δηλαδή το \texttt{0x7FFFFFFF}), στο παρεχόμενο reference model (\texttt{nn\_model.v}) επιστρέφεται η τιμή \texttt{\textbf{0xFFFFFFFF}} (γραμμή 95).

\textbf{Απόφαση:} Προσαρμόσαμε το \texttt{nn.v} ώστε να επιστρέφει \texttt{\textbf{0xFFFFFFFF}} για να περνάει επιτυχώς το \textbf{testbench}, παρόλου που σε 32-bit signed αναπαράσταση, το \texttt{0xFFFFFFFF} αντιστοιχεί στο $-1$, όχι στον max positive.

\begin{lstlisting}[caption=Ακολουθούμε το nn\_model για να περάσει το testbench, language=Verilog]
case (state)
  //==================================================================
  // Constants
  //==================================================================
  localparam [31:0] OVERFLOW_VALUE = 32'hFFFFFFFF; //adapted to nn_model
  localparam [2:0]  NO_OVERFLOW    = 3'b111;
  localparam [2:0]  NO_ZERO        = 3'b111;
endcase
\end{lstlisting}

\subsection{Register File Pre-fetching}

\subsubsection{Πρόβλημα: Σύγχρονη Ανάγνωση Register File}
Το Register File (Άσκηση 3) υλοποιεί \textbf{σύγχρονη ανάγνωση} (registered outputs). Αυτό σημαίνει ότι τα δεδομένα εμφανίζονται στις εξόδους \texttt{readData} \textbf{έναν κύκλο μετά} τον ορισμό της διεύθυνσης \texttt{readReg}.

\subsubsection{Λύση: Address Pre-fetching}
Για να αντιμετωπιστεί αυτή η καθυστέρηση, το FSM εφαρμόζει τεχνική \textbf{pre-fetching διευθύνσεων}. Οι διευθύνσεις τίθενται στην \textbf{προηγούμενη κατάσταση} από ότι χρειάζονται τα δεδομένα. Αυτή η τεχνική ``read-ahead'' εξασφαλίζει ότι τα δεδομένα είναι έτοιμα όταν τα χρειάζονται οι ALU/MAC, χωρίς να χρειάζονται επιπλέον κύκλοι αναμονής:

\begin{lstlisting}[caption=Pre-fetching διευθύνσεων στο nn.v, language=Verilog]
case (state)
    // In S2=IDLE we set the addresses for S3=PREPROCESS
    S_IDLE, S_DEACTIVATED: begin
        rf_readReg1 = ADDR_SHIFT_BIAS_1;  // -> data for S_PREPROCESS
        rf_readReg2 = ADDR_SHIFT_BIAS_2;
    end
    
    // In S3=PREPROCESS we set the addresses for S4=INPUT_LAYER
    S_PREPROCESS: begin
        rf_readReg1 = ADDR_WEIGHT_1;      // -> data for S_INPUT_LAYER
        rf_readReg2 = ADDR_BIAS_1;
        rf_readReg3 = ADDR_WEIGHT_2;
        rf_readReg4 = ADDR_BIAS_2;
    end
    // ... etc.
endcase
\end{lstlisting}

\subsubsection{Χρονοδιάγραμμα Pre-fetching}
Στον παρακάτω πίνακα φαίνεται για κάθε state του FSM (κατά την διάρκεια της κανονικής εκτέλεσης του προγράμματος), τα ποιων διευθύνσεων τα δεδομένα "ζητούνται" απο το Register File και ποια είναι ήδη έτοιμα για επεξεργασία.

\begin{table}[H]
\centering
\caption{Χρονοδιάγραμμα Pre-fetching διευθύνσεων RegFile}
\label{tab:prefetching}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Τρέχουσα Κατάσταση} & \textbf{Διευθύνσεις (set)} & \textbf{Δεδομένα (available)} \\
\hline
S\_IDLE / S\_DEACTIVATED & shift\_bias\_1, shift\_bias\_2 & (Μη έγκυρα) \\
\hline
S\_PREPROCESS & weight\_1, bias\_1, weight\_2, bias\_2 & shift\_bias\_1, shift\_bias\_2 \\
\hline
S\_INPUT\_LAYER & weight\_3, bias\_3 & weight\_1, bias\_1, weight\_2, bias\_2 \\
\hline
S\_OUTPUT\_LAYER1 & weight\_4 & weight\_3, bias\_3 \\
\hline
S\_OUTPUT\_LAYER2 & shift\_bias\_3 & weight\_4 \\
\hline
S\_POSTPROCESS & -- & shift\_bias\_3 \\
\hline
\end{tabular}
\end{table}



\subsection{Testbench Νευρωνικού}

Το testbench εκτελεί 100 επαναλήψεις με 3 τεστ ανά επανάληψη, όπου κάθε επανάληψη τεστάρει το νευρωνικό για τυχαία παραγόμενο ζεύγος εισόδων με εύρος τιμών:
\begin{enumerate}
    \item \textbf{Κανονικό εύρος:} [-4096, 4095]
    \item \textbf{Θετικό overflow:} [MAX\_POS/2, MAX\_POS]
    \item \textbf{Αρνητικό overflow:} [MAX\_NEG, MAX\_NEG/2]
\end{enumerate}

\subsubsection{Latency Calibration}
Η συνάρτηση αναφοράς \texttt{nn\_model} υπολογίζει το αναμενόμενο αποτέλεσμα για σύγκριση. Ωστόσο, καθώς αυτό είναι στιγμιαίο, αλλά το κύκλωμα του νευρωνικού έχει καθυστέρηση λόγω
του FSM, αν γίνει σύγκριση πολύ νωρίς, το τεστ αποτυγχάνει ακόμα και αν το κύκλωμα λειτουργεί σωστά. 

Αφού τα έγκυρα δεδομένα εμφανίζονται στο νευρωνικό ακριβώς 6 κύκλους μετά τον παλμό enable (σύμφωνα με αριθμό καταστάσεων του FSM που διατρέχονται ), εφαρμόστηκε το εξείς Latency:

\begin{lstlisting}[style=verilogstyle]
// Starting next test:
@(posedge clk);
    enable = 1;
@(posedge clk);
    enable = 0;
// Generating expected result
expected_val = nn_model(in1, in2);
// Wait 6 cycles
repeat(6) @(posedge clk);  
// Now the both results are ready and can be compared...
\end{lstlisting}

\subsubsection{Αποτελέσματα Testbench}
Τα αποτελέσματα της προσομοίωσης, όπως καταγράφηκαν από το testbench, παρουσιάζονται παρακάτω στο Figure \ref{fig:tb_results}.

\begin{figure}[H]
    \centering
    \begin{verbatim}
Loading weights...
Weights loaded. Starting tests...

============================================================
FINAL REPORT
============================================================
Total Test Cases: 300
PASSED:           300
FAILED:           0
Success Rate:     300 / 300
RESULT: SUCCESS (All tests passed)
============================================================
    \end{verbatim}
    \caption{Στιγμιότυπο κονσόλας από την εκτέλεση του \texttt{tb\_nn.v}}\label{fig:tb_results}
\end{figure}

Όπως φαίνεται από την τελική αναφορά, το κύκλωμα πέρασε επιτυχώς και τις 300 περιπτώσεις ελέγχου (\textbf{100\% επιτυχία}), επιβεβαιώνοντας την ορθότητα της σχεδίασης του FSM, της διαχείρισης των καταχωρητών και της λογικής ανίχνευσης υπερχείλισης.


\subsection{Κυματομορφές Νευρωνικού Δικτύου}
Παρακάτω, παρουσιάζονται οι κυματομορφές από την προσομοίωση του tb nn.v (Figure \ref{fig:waveform_ex4}), εστιάζοντας στα πρώτα στάδια της εκτέλεσης (Loading και πρώτες επαναλήψεις ελέγχου). Παρατηρούμε τα εξής στάδια λειτουργίας:

\begin{itemize}
    \item \textbf{Αρχικοποίηση \& Φόρτωση (0 - 200ns):} 
    Στην αρχή βλέπουμε την ενεργοποίηση του \texttt{resetn} και τον πρώτο παλμό του \texttt{enable}. Το σύστημα μεταβαίνει στην κατάσταση \texttt{S\_LOADING} (δεν φαίνεται το state signal αλλά φαίνεται η καθυστέρηση μέχρι την ετοιμότητα).
    
    \item \textbf{Κανονική Λειτουργία (First test, 200 - 270ns):}
    Εφαρμόζονται οι είσοδοι \texttt{input\_1} και \texttt{input\_2} και δινεται enable. Μετά από έναν κύκλο το αναμενόμενο αποτέλεσμα (\texttt{expected}) εμφανίζεται στην κυματομορφή, ενώ το ίδιο αποτέλεσμα εμφανίζεται στην έξοδο του νευρωνικού (\texttt{final\_output}) σε 6 κύκλους λόγω του FSM (όπως αναφέραμε στην παράγραφο 5.6.1). Καθώς και οι δύο έξοδοι συμφωνούν στην τιμή \texttt{0xfffd5134}, το σήμα \texttt{pass\_count} αυξάνεται σε 1. Δεν υπάρχει υπερχείλιση (\texttt{total\_ovf = 0}).

    \item \textbf{Διαχείριση Υπερχείλισης (Second test, 280 - 310ns):}
    Στο δεύτερο test, παρατηρούμε ότι το σήμα \texttt{total\_ovf} γίνεται 1 (high). Αυτό υποδεικνύει ότι προέκυψε υπερχείλιση κατά τους υπολογισμούς. Όπως είναι αναμενόμενο, η έξοδος \texttt{final\_output} οδηγείται στην τιμή \texttt{0xffffffff} (Saturation Value), που ταυτίζεται με το \texttt{expected} value του μοντέλου αναφοράς, επιβεβαιώνοντας ότι το κύκλωμα διαχειρίζεται σωστά τα overflows και συμμορφώνεται με το μοντέλο.
\end{itemize}

\begin{figure}[ht]
    \centering
    \makebox[\textwidth][c]{\includegraphics[width=1.1\textwidth]{Waveforms/Exercise_4 - Waveform.png}}
    \caption{Κυματομορφές προσομοίωσης του Νευρωνικού Δικτύου. Φαίνεται η αρχικοποίηση και οι πρώτες επαναλήψεις ελέγχου (Normal και Overflow cases).}
    \label{fig:waveform_ex4}
\end{figure}
\newpage
\justify
\textbf{Συνολική Εικόνα:}
    Το σήμα \texttt{fail\_count} παραμένει σταθερά στο 0, ενώ το \texttt{pass\_count} αυξάνεται σε κάθε θετικό μέτωπο του ρολογιού μετά την ολοκλήρωση κάθε πράξης, αποδεικνύοντας την ορθή λειτουργία του συστήματος για διαφορετικά σενάρια εισόδου (Figure \ref{fig:waveform2_ex4}).

    \begin{figure}[ht]
    \centering
    \makebox[\textwidth][c]{\includegraphics[width=1.1\textwidth]{Waveforms/Exercise_4 - Waveform2.png}}
    \caption{Κυματομορφές προσομοίωσης του Νευρωνικού Δικτύου (Συνολική Εικόνα).}
    \label{fig:waveform2_ex4}
\end{figure}
\newpage
      
\newpage